<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8"/>
    <title>TD</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
    </style>
    <script src="https://github.com/photonstorm/phaser-ce/releases/download/v2.9.4/phaser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.18.1/math.min.js"></script>
    <script src="js/styles.js"></script>
    <script src="js/inits.js"></script>
</head>

<body>
<script>
    var game = new Phaser.Game(1280, 720, Phaser.AUTO, null, {preload: preload, create: create, update: update});

    var TD = new function () {
        var gold;
        var wave;

        Object.defineProperty(this, "gold", {
            get: function () {
                return gold;
            },
            set: function (value) {
                gold = value;
                this.goldText.setText(this.gold);
            }
        });

        Object.defineProperty(this, "wave", {
            get: function () {
                return wave;
            },
            set: function (value) {
                wave = value;
                this.waveText.setText('Wave: ' + this.wave);
            }
        });

        this.init = function () {
            this.gold = 100;
            this.wave = 0;
        }
    };

    var wayPoints = [];

    var textures = {};


    var buildingTower;
    var isBuildingTower;

    function preload() {
        game.scale.scaleMode = Phaser.ScaleManager.NO_SCALE;
        game.scale.pageAlignHorizontally = true;
        game.scale.pageAlignVertically = true;
        game.stage.backgroundColor = '#eee';
    }

    function create() {
        game.physics.startSystem(Phaser.Physics.ARCADE);

        setWayPoints();
        createTextures();
        initWay();
        initCastle();
        initTowers();
        initEnemies();
        initSidebar();
        TD.init();
        startNextWave();
    }

    function update() {
        game.physics.arcade.overlap(TD.towers, TD.enemies, attackEnemies, checkTrueOverlapping);
        if (isBuildingTower) {
            buildingTower.x = game.input.x;
            buildingTower.y = game.input.y;
            if (game.input.activePointer.isDown)
                activateTower(buildingTower);
        }
    }

    function checkTrueOverlapping(tower, enemy) {
        var overlapped = game.physics.arcade.distanceBetween(tower, enemy) < tower.range + enemy.size / 2;
        if (tower.focusedEnemy === enemy && !overlapped)
            tower.focusedEnemy = null;
        return overlapped;
    }

    function attackEnemies(tower, enemy) {
        if (enemy.focusable)
            tower.focusedEnemy = tower.focusedEnemy || enemy;
        else
            return;

        if (tower.focusedEnemy !== enemy)
            return;
        enemy.hp -= tower.attack;
        console.log(enemy.name + ' attacked by ' + tower.name + ': -' + tower.attack);
        if (enemy.hp <= 0) {
            TD.gold += enemy.size / 4;
            tower.focusedEnemy = null;
            killEnemy(enemy);
            console.log(enemy.name + ' killed by ' + tower.name);
        }
    }

    function killEnemy(enemy) {
        enemy.focusable = false;
        enemy.moveTween.stop();
        var killTween = game.add.tween(enemy);
        killTween.to({width: 2 * enemy.size, height: 2 * enemy.size, alpha: 0}, 200, Phaser.Easing.Linear.None);
        killTween.onComplete.addOnce(function () {
            enemy.kill();
            TD.enemies.remove(enemy);
            if (!TD.enemies.total)
                setTimeout(startNextWave, 1000 * nextWaveTimeout);
        }, this);
        killTween.start();
    }

    function attackCastle(enemy) {
        console.log(enemy.name + ': '+ enemy.hp);
        TD.castle.hp -= enemy.hp;
        killEnemy(enemy);
        if (TD.castle.hp <= 0)
            gameOver();
    }

    function startNextWave() {
        TD.wave++;
        var enemiesCount = 2 + TD.wave;
        /*if (TD.wave % 5 === 0) {

        } else {*/
            for (var i = 0; i < enemiesCount; i++) {
                var newEnemy = game.add.sprite(styles.sidebarWidth + styles.worldPadding, -styles.worldPadding - i * (baseEnemyInfo.size / 2 + baseEnemyInfo.margin), textures.enemy);
                newEnemy.anchor.set(0.5);
                game.physics.enable(newEnemy, Phaser.Physics.ARCADE);

                Object.assign(newEnemy, baseEnemyInfo);

                newEnemy.name = "Enemy " + TD.wave + '.' + enemyN++;
                TD.enemies.add(newEnemy);

                move(newEnemy);
            }
        //}
        enemyN = 0;

        function move(enemy, i) {
            i = i === undefined ? 0 : i;
            if (i >= wayPoints.length) {
                attackCastle(enemy);
                return;
            }
            var moveTween = game.add.tween(enemy);
            enemy.moveTween = moveTween;
            moveTween.to({x: wayPoints[i].x, y: wayPoints[i].y},
                game.physics.arcade.distanceBetween(enemy, wayPoints[i]) / enemy.speed * 1000,
                Phaser.Easing.Linear.None);
            moveTween.onComplete.addOnce(function () {
                move(enemy, ++i)
            }, this);
            moveTween.start();
        }
    }

    function buyTower() {
        if (TD.gold >= baseTowerInfo.price) {
            TD.gold -= baseTowerInfo.price;
            var newTower = game.add.sprite(game.input.x, game.input.y, textures.tower);
            newTower.anchor.set(0.5);
            game.physics.enable(newTower, Phaser.Physics.ARCADE);
            buildingTower = newTower;
            isBuildingTower = true;
        }
    }

    function activateTower(tower) {
        isBuildingTower = false;
        Object.assign(tower, baseTowerInfo);
        TD.towers.add(tower);
    }

    function gameOver() {
        alert('You lose! Castle HP = ' + TD.castle.hp);
        location.reload();
    }
</script>
</body>

</html>
